// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectionRequest {
    #[prost(enumeration = "connection_request::Type", tag = "1")]
    pub r#type: i32,
    #[prost(string, tag = "2")]
    pub client_name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub client_identifier: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `ConnectionRequest`.
pub mod connection_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Rpc = 0,
        Stream = 1,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Rpc => "RPC",
                Type::Stream => "STREAM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RPC" => Some(Self::Rpc),
                "STREAM" => Some(Self::Stream),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectionResponse {
    #[prost(enumeration = "connection_response::Status", tag = "1")]
    pub status: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub client_identifier: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `ConnectionResponse`.
pub mod connection_response {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Ok = 0,
        MalformedMessage = 1,
        Timeout = 2,
        WrongType = 3,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::Ok => "OK",
                Status::MalformedMessage => "MALFORMED_MESSAGE",
                Status::Timeout => "TIMEOUT",
                Status::WrongType => "WRONG_TYPE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OK" => Some(Self::Ok),
                "MALFORMED_MESSAGE" => Some(Self::MalformedMessage),
                "TIMEOUT" => Some(Self::Timeout),
                "WRONG_TYPE" => Some(Self::WrongType),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Request {
    #[prost(message, repeated, tag = "1")]
    pub calls: ::prost::alloc::vec::Vec<ProcedureCall>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcedureCall {
    #[prost(string, tag = "1")]
    pub service: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub procedure: ::prost::alloc::string::String,
    #[prost(uint32, tag = "4")]
    pub service_id: u32,
    #[prost(uint32, tag = "5")]
    pub procedure_id: u32,
    #[prost(message, repeated, tag = "3")]
    pub arguments: ::prost::alloc::vec::Vec<Argument>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Argument {
    #[prost(uint32, tag = "1")]
    pub position: u32,
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Response {
    #[prost(message, optional, tag = "1")]
    pub error: ::core::option::Option<Error>,
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<ProcedureResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcedureResult {
    #[prost(message, optional, tag = "1")]
    pub error: ::core::option::Option<Error>,
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Error {
    #[prost(string, tag = "1")]
    pub service: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub stack_trace: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamUpdate {
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<StreamResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamResult {
    #[prost(uint64, tag = "1")]
    pub id: u64,
    #[prost(message, optional, tag = "2")]
    pub result: ::core::option::Option<ProcedureResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Services {
    #[prost(message, repeated, tag = "1")]
    pub services: ::prost::alloc::vec::Vec<Service>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Service {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub procedures: ::prost::alloc::vec::Vec<Procedure>,
    #[prost(message, repeated, tag = "3")]
    pub classes: ::prost::alloc::vec::Vec<Class>,
    #[prost(message, repeated, tag = "4")]
    pub enumerations: ::prost::alloc::vec::Vec<Enumeration>,
    #[prost(message, repeated, tag = "5")]
    pub exceptions: ::prost::alloc::vec::Vec<Exception>,
    #[prost(string, tag = "6")]
    pub documentation: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Procedure {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub parameters: ::prost::alloc::vec::Vec<Parameter>,
    #[prost(message, optional, tag = "3")]
    pub return_type: ::core::option::Option<Type>,
    #[prost(bool, tag = "4")]
    pub return_is_nullable: bool,
    #[prost(enumeration = "procedure::GameScene", repeated, tag = "6")]
    pub game_scenes: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, tag = "5")]
    pub documentation: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Procedure`.
pub mod procedure {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GameScene {
        SpaceCenter = 0,
        Flight = 1,
        TrackingStation = 2,
        EditorVab = 3,
        EditorSph = 4,
        MissionBuilder = 5,
    }
    impl GameScene {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                GameScene::SpaceCenter => "SPACE_CENTER",
                GameScene::Flight => "FLIGHT",
                GameScene::TrackingStation => "TRACKING_STATION",
                GameScene::EditorVab => "EDITOR_VAB",
                GameScene::EditorSph => "EDITOR_SPH",
                GameScene::MissionBuilder => "MISSION_BUILDER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SPACE_CENTER" => Some(Self::SpaceCenter),
                "FLIGHT" => Some(Self::Flight),
                "TRACKING_STATION" => Some(Self::TrackingStation),
                "EDITOR_VAB" => Some(Self::EditorVab),
                "EDITOR_SPH" => Some(Self::EditorSph),
                "MISSION_BUILDER" => Some(Self::MissionBuilder),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Parameter {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub r#type: ::core::option::Option<Type>,
    #[prost(bytes = "vec", tag = "3")]
    pub default_value: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "4")]
    pub nullable: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Class {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub documentation: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Enumeration {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub values: ::prost::alloc::vec::Vec<EnumerationValue>,
    #[prost(string, tag = "3")]
    pub documentation: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnumerationValue {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub value: i32,
    #[prost(string, tag = "3")]
    pub documentation: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Exception {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub documentation: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Type {
    #[prost(enumeration = "r#type::TypeCode", tag = "1")]
    pub code: i32,
    #[prost(string, tag = "2")]
    pub service: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub types: ::prost::alloc::vec::Vec<Type>,
}
/// Nested message and enum types in `Type`.
pub mod r#type {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TypeCode {
        None = 0,
        /// Values
        Double = 1,
        Float = 2,
        Sint32 = 3,
        Sint64 = 4,
        Uint32 = 5,
        Uint64 = 6,
        Bool = 7,
        String = 8,
        Bytes = 9,
        /// Objects
        Class = 100,
        Enumeration = 101,
        /// Messages
        Event = 200,
        ProcedureCall = 201,
        Stream = 202,
        Status = 203,
        Services = 204,
        /// Collections
        Tuple = 300,
        List = 301,
        Set = 302,
        Dictionary = 303,
    }
    impl TypeCode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TypeCode::None => "NONE",
                TypeCode::Double => "DOUBLE",
                TypeCode::Float => "FLOAT",
                TypeCode::Sint32 => "SINT32",
                TypeCode::Sint64 => "SINT64",
                TypeCode::Uint32 => "UINT32",
                TypeCode::Uint64 => "UINT64",
                TypeCode::Bool => "BOOL",
                TypeCode::String => "STRING",
                TypeCode::Bytes => "BYTES",
                TypeCode::Class => "CLASS",
                TypeCode::Enumeration => "ENUMERATION",
                TypeCode::Event => "EVENT",
                TypeCode::ProcedureCall => "PROCEDURE_CALL",
                TypeCode::Stream => "STREAM",
                TypeCode::Status => "STATUS",
                TypeCode::Services => "SERVICES",
                TypeCode::Tuple => "TUPLE",
                TypeCode::List => "LIST",
                TypeCode::Set => "SET",
                TypeCode::Dictionary => "DICTIONARY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "DOUBLE" => Some(Self::Double),
                "FLOAT" => Some(Self::Float),
                "SINT32" => Some(Self::Sint32),
                "SINT64" => Some(Self::Sint64),
                "UINT32" => Some(Self::Uint32),
                "UINT64" => Some(Self::Uint64),
                "BOOL" => Some(Self::Bool),
                "STRING" => Some(Self::String),
                "BYTES" => Some(Self::Bytes),
                "CLASS" => Some(Self::Class),
                "ENUMERATION" => Some(Self::Enumeration),
                "EVENT" => Some(Self::Event),
                "PROCEDURE_CALL" => Some(Self::ProcedureCall),
                "STREAM" => Some(Self::Stream),
                "STATUS" => Some(Self::Status),
                "SERVICES" => Some(Self::Services),
                "TUPLE" => Some(Self::Tuple),
                "LIST" => Some(Self::List),
                "SET" => Some(Self::Set),
                "DICTIONARY" => Some(Self::Dictionary),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tuple {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct List {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Set {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Dictionary {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<DictionaryEntry>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DictionaryEntry {
    #[prost(bytes = "vec", tag = "1")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Stream {
    #[prost(uint64, tag = "1")]
    pub id: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Event {
    #[prost(message, optional, tag = "1")]
    pub stream: ::core::option::Option<Stream>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Status {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub bytes_read: u64,
    #[prost(uint64, tag = "3")]
    pub bytes_written: u64,
    #[prost(float, tag = "4")]
    pub bytes_read_rate: f32,
    #[prost(float, tag = "5")]
    pub bytes_written_rate: f32,
    #[prost(uint64, tag = "6")]
    pub rpcs_executed: u64,
    #[prost(float, tag = "7")]
    pub rpc_rate: f32,
    #[prost(bool, tag = "8")]
    pub one_rpc_per_update: bool,
    #[prost(uint32, tag = "9")]
    pub max_time_per_update: u32,
    #[prost(bool, tag = "10")]
    pub adaptive_rate_control: bool,
    #[prost(bool, tag = "11")]
    pub blocking_recv: bool,
    #[prost(uint32, tag = "12")]
    pub recv_timeout: u32,
    #[prost(float, tag = "13")]
    pub time_per_rpc_update: f32,
    #[prost(float, tag = "14")]
    pub poll_time_per_rpc_update: f32,
    #[prost(float, tag = "15")]
    pub exec_time_per_rpc_update: f32,
    #[prost(uint32, tag = "16")]
    pub stream_rpcs: u32,
    #[prost(uint64, tag = "17")]
    pub stream_rpcs_executed: u64,
    #[prost(float, tag = "18")]
    pub stream_rpc_rate: f32,
    #[prost(float, tag = "19")]
    pub time_per_stream_update: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultiplexedRequest {
    #[prost(message, optional, tag = "1")]
    pub connection_request: ::core::option::Option<ConnectionRequest>,
    #[prost(message, optional, tag = "2")]
    pub request: ::core::option::Option<Request>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultiplexedResponse {
    #[prost(message, optional, tag = "1")]
    pub response: ::core::option::Option<Response>,
    #[prost(message, optional, tag = "2")]
    pub stream_update: ::core::option::Option<StreamUpdate>,
}
